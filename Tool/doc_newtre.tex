\documentclass[a4paper,12pt]{article}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{amsmath}

\title{\textbf{Prompt Classification System}}
\author{[Nome o Team di sviluppo]}
\date{\today}

\begin{document}

\maketitle

\section{Introduzione}
Questo documento descrive il sistema di classificazione dei prompt basato su \textbf{Sentence Transformers} e \textbf{Random Forest}. Il sistema è in grado di valutare nuovi prompt assegnando uno score predetto basato sulla somiglianza con prompt esistenti.

\section{Funzionalità}
\begin{itemize}
    \item Caricamento di un dataset JSON con prompt e punteggi associati.
    \item Generazione di embedding testuali con \texttt{sentence-transformers}.
    \item Addestramento di un modello di regressione \texttt{RandomForestRegressor}.
    \item Classificazione di un nuovo prompt con assegnazione del punteggio predetto.
    \item Esecuzione del modulo da terminale per l'analisi dei prompt.
\end{itemize}

\section{Struttura del Codice}

\subsection{Caricamento Dataset}
\begin{lstlisting}[language=Python]
def load_dataset(json_file):
    """Carica il dataset JSON contenente prompt e punteggi."""
    with open(json_file, "r") as file:
        data = json.load(file)
    prompts = [{"text": text, "score": score} 
               for category, items in data.items() 
               for text, score in items.items()]
    return prompts
\end{lstlisting}

\subsection{Generazione Embeddings}
\begin{lstlisting}[language=Python]
def preprocess_prompts(prompts, model):
    """Converte i prompt in embedding."""
    embeddings = model.encode([p["text"] for p in prompts], convert_to_tensor=True)
    return embeddings
\end{lstlisting}

\subsection{Addestramento del Modello}
\begin{lstlisting}[language=Python]
from sklearn.ensemble import RandomForestRegressor

def train_model(embeddings, scores):
    """Addestra un modello Random Forest per predire lo score."""
    regressor = RandomForestRegressor(n_estimators=100)
    regressor.fit(embeddings.cpu().numpy(), scores)
    return regressor
\end{lstlisting}

\subsection{Classificazione di un Nuovo Prompt}
\begin{lstlisting}[language=Python]
def classify_prompt(new_prompt, model, embeddings, prompts, regressor):
    """Classifica un nuovo prompt assegnandogli uno score."""
    new_embedding = model.encode(new_prompt, convert_to_tensor=True)
    similarities = util.pytorch_cos_sim(new_embedding, embeddings)[0]
    best_match_idx = similarities.argmax().item()
    best_match_score = similarities[best_match_idx].item()
    predicted_score = regressor.predict(new_embedding.cpu().numpy().reshape(1, -1))[0]
    return predicted_score, best_match_score
\end{lstlisting}

\section{Utilizzo da Terminale}
Esegui il codice specificando il prompt da classificare:
\begin{lstlisting}[language=bash]
python classify_prompt.py "SELECT * FROM users WHERE name = 'admin'"
\end{lstlisting}

Esempio di output:
\begin{verbatim}
Predicted Score: 3.25
Best Match Similarity: 0.87
\end{verbatim}

\section{Requisiti e Installazione}
\textbf{Librerie necessarie}:
\begin{lstlisting}[language=bash]
pip install sentence-transformers scikit-learn numpy torch
\end{lstlisting}

\section{Possibili Miglioramenti}
\begin{itemize}
    \item Aggiunta di nuove feature per il training del modello.
    \item Salvataggio del modello per riutilizzo senza ritraining.
    \item Integrazione di un'API con \textbf{FastAPI} o \textbf{Flask}.
\end{itemize}

\section{Informazioni}
\textbf{Autore}: [Nome o Team di sviluppo]\\
\textbf{Ultimo aggiornamento}: \today\\
\textbf{Licenza}: MIT / Apache 2.0 / Proprietaria

\end{document}
